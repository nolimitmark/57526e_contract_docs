## **ROX Assessment**

Like mentioned in the previous article, `BIN` and `ROX` are both tokens. `BIN` is very basic, with standard features like transfers, approvals..... `ROX`, on the other hand, includes those same basic features but adds more advanced functionality. These include rewarding users who hold `ROX`, rewarding users who provide liquidity to the `ROX/BIN` pool, and rewarding certain special **nodes**.

Both `BIN` and `ROX` are decentralized. BIN was decentralized immediately upon deployment, while `ROX` became decentralized after ownership was renounced.

The **nodes** that earn rewards are more centralized. An admin can add or remove these nodes. For now, we can at least ignore this part, since it is not the main focus of this assessment.

The **DAO** contract `0x8e789a939E8e38F2D5E2DD08273aB22771547b73` mainly acts as a proxy and forwards calls to another hidden contract. For the purpose of this assessment, it is not a major concern and is not analyzed further.

The main concern here is the **investment contract** at
 `0x09774dED63D8CC41a835a802E21eDFeb80814d6B`.

If we completely ignore this investment contract, then there are only two ways to earn from the ROX project:

1. Buy and hold ROX tokens, which automatically places you among the dividend earners.
2. Provide liquidity to the ROX/BIN pool, which automatically places you among the liquidity providers.

In both cases, earnings come from transaction fees generated by certain activities across the network, depending on which program the user is part of.

One important detail is that **nodes are prioritized first**, and whatever balance remains is then distributed between token holders and liquidity providers.

**With that in mind, we now return to the investment contract.**

In this contract, we'll focus on the two key functions `deposit` and `withdraw`.

### **Deposit** 

This function is used to add liquidity to the pool. When it is called, it first attempts to process any previous deposits already waiting in the queue, as long as certain conditions are met. During this process, the interest meant to be earned from a deposit is split into two parts: `(100 - 15)%` and `15%`.

The **15%**, treated as fees, is taken from the deposit and sent to a **DAO** contract owned by the organization. The remaining amount is then added to the `ROX/BIN` liquidity pool. After that, the new deposit itself is pushed into the queue.

In practice, this means that anyone investing through this contract is indirectly adding liquidity to the `ROX/BIN` pool. However, everything happens through this single contract, which aggregates all user deposits and effectively behaves like one large liquidity provider.

Under normal circumstances, providing liquidity to a pool rewards the provider with **liquidity provider (LP) tokens**. These tokens can be sold at any time, and their value increases or decreases as the pool grows or shrinks.

Here, although the contract adds liquidity to the `ROX/BIN` pool, it does not keep the LP tokens. Instead, they are sent to a “dead wallet,” effectively burning them. On its own, this is not necessarily a bad practice. The team controls the liquidity and may simply want the pool size to continuously increase. There is likely a reason behind this design.

### **Withdrawal** 

When a user wants to withdraw, this function is called. The `ROX` tokens held in the contract’s balance are converted along the path `ROX → BIN → USDT`.

The interest portion of the deposit, which was originally `(100 - 15)%`, is split again into `(100 - 15 - 30)%`. From this, **30%** is sent to the DAO once more, while the remaining **55%** is paid out to the user.

At this point, an obvious question comes up: **how can we be sure this contract will always have enough funds to cover withdrawals?**

At the end of every withdrawal, the following line is executed:

```solidity
IToken(ROX).reSync(spentToken);
```

This calls the `reSync` function defined in the `ROX` contract, passing in the exact amount that was just paid to the user.

```solidity
function reSync(uint amount) external {
    require(msg.sender == pool, "invalid caller");
    uint pairBalance = balanceOf(address(uniswapV2Pair));
    uint maxAmount = pairBalance / 3;
    if (amount > maxAmount) {
        amount = maxAmount;
    }
    super._transfer(uniswapV2Pair, pool, amount);
    IUniswapV2Pair(uniswapV2Pair).sync();
}
```

This function, which can only be called by the investment contract, works as follows:

Let the amount paid to the user be `x`, and let the total `ROX` balance in the `ROX/BIN` liquidity pool be `y`.

- First, it checks whether `x` is greater than one-third of `y`. If it is, `x` is capped at that one-third value.
- It then transfers `x` amount of `ROX` directly from the liquidity pool back to the investment contract.
- Finally, it calls `sync()` to rebalance the pool.

The result is that the liquidity pool shrinks slightly after each withdrawal. This also shows that even though the LP tokens are burned, value is still being extracted directly from the pool later on.

### **Overall Observation**

This full flow between deposits and withdrawals clearly forms a cycle: new deposits are used to fund withdrawals. Because of this, the system is likely to start misbehaving once new investments slow down or users stop providing liquidity.